#!/usr/bin/env bash

# Provides a convinient workflow for quickly recalling previously opened files
# from dmenu

# CHANGE EDITOR AND DMENU COMMANDS TO SUIT YOUR NEEDS!
editor_cmd=(subl)
dmenu_cmd=(dmenu-wrapper -i -l 50 -p "File history:")

help='Usage:

1) Open a new file (or directory) from cmd-line:
   $ dmenu-editor-history --open example.txt
   (intented to be run via a shell alias)

2) Open a previously opened file from dmenu:
   $ dmenu-editor-history
   (intented to be run via a custom hotkey)

   Clear history:
   $ dmenu-editor-history --clear

   Print out this help text:
   $ dmenu-editor-history --help'

err() {
    printf "ERROR: $1!\n" 1>&2
    exit 1
}

# file to store history in
if [[ -d $XDG_CACHE_HOME ]]; then
    histfile="$XDG_CACHE_HOME/dmenu-editor-history"
elif [[ -d $HOME ]]; then
    histfile="$HOME/.dmenu-editor-history"
else
    err 'issue with history file path'
fi
[[ -f $histfile ]] || touch "$histfile"

new_hist_item() {
    # $1 = absolute path to a file

    temphist='/tmp/dmenu-editor-history-tmp'

    printf "$1\n" > "$temphist" 

    # if a directory also add the files inside because that's what I like
    # (only regular files in first depth, not recursive)
    if [[ -d $1 ]]; then
        for f in "$1"/*; do
            [[ -f $f ]] && printf "$f\n" >> "$temphist"
        done
    fi

    # adding previous part of history without duplicates of new items
    dont_duplicate=$(while read; do printf "$REPLY "; done < $temphist)
    while read; do
        for item in $dont_duplicate; do
            [[ $REPLY = $item ]] && continue 2
        done
        printf "$REPLY\n"
    done < "$histfile" >> "$temphist"

    mv "$temphist" "$histfile"
}

## cmd arguments
case "$1" in
    '')
        dir_indicator='[DIR]'

        # pipe file into dmenu with indicator for directories
        filename="$(
            while read; do
                if [[ -d $REPLY ]]; then
                    printf "$dir_indicator $REPLY\n"
                else
                    printf "$REPLY\n"
                fi
            done < "$histfile" | "${dmenu_cmd[@]}"
        )"

        [[ -z $filename ]] && err 'empty selection'

        filename=${filename/"$dir_indicator" /}

        # if the file doesn't exit remove it from the list and error out
        if ! [[ -e $filename ]]; then
            printf "$(while read; do
                    [[ $REPLY = $filename ]] || printf "$REPLY\n"
                    done < $histfile)\n" > "$histfile"
            err "$filename does not exist"
        fi

        new_hist_item "$filename"
        "${editor_cmd[@]}" "$filename" ;;

    --open)
        # absolute path to specified file
        case "$2" in
            '')
                "${editor_cmd[@]}"
                exit ;;
            .)
                filename="$PWD" ;;
            ..)
                cwd="${PWD##*/}"
                filename="${PWD%/$cwd}" ;;
            *)
                filename="$PWD/${2##*/}" ;;
        esac

        new_hist_item "$filename"
        "${editor_cmd[@]}" "$filename" ;;

    --clear)
        read -p "delete $histfile? [y/n]: " del
        case "$del" in
            y|Y|yes|Yes|YES) rm -v "$histfile"
        esac ;;

    --help)
        printf "$help\n" ;;

    *)
        err 'invalid option(s), see --help for information about usage' ;;
esac
