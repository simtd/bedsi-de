#!/usr/bin/env bash

# TODO: fix some duplicates in generated history from --fill

# DMENU-EDITOR-HISTORY
# --------------------

# Bash script that provides an editor-indepentend selectable history list for
# opened files, via dmenu. See --help for usage.

# Change editor and dmenu commands to suit your needs!
editor_cmd=(subl)
dmenu_cmd=(fzfmenu "--prompt='Hist > '")

# Shell options
shopt -s dotglob # (include hidden files)
shopt -s extglob

err() {
    printf "ERROR: $1!\n" 1>&2
    exit 1
}

# File to store history in
if [[ -d $XDG_CACHE_HOME ]]; then
    hist="$XDG_CACHE_HOME/dmenu-editor-history"
elif [[ -d $HOME ]]; then
    hist="$HOME/.dmenu-editor-history"
else
    err 'XDG_CACHE_HOME or HOME environment variable needs to be set'
fi
[[ -f $hist ]] || touch "$hist"

temp='/tmp/dmenu-editor-history-tmp'

entry() {
    # New history entry, directories get turned into multiple entries

    # Arguments:
    # $1 = absolute path to a file

    printf '%s\n' "$1" > "$temp"
    len=1

    # If a directory also add the files inside because that's what I like
    if [[ -d $1 ]]; then
        for f in "$1"/*; do
            if [[ -e $f ]]; then
                printf '%s\n' "$f"
                (( len++ ))
            fi >> "$temp"
        done
    fi

    # Adding previous part of history without duplicates of new entries
    local IFS=$'\n'
    dupcount=0
    while read; do
        if [[ $dupcount -lt $len ]]; then
            for ent in $(< $temp); do
                if [[ $REPLY == $ent ]]; then
                    (( dupcount++ ))
                    continue 2
                fi
            done
        fi
        printf '%s\n' "$REPLY"
    done < "$hist" >> "$temp"

    mv "$temp" "$hist"
}

rm_non_exist() {
    # Remove non-existant files from history

    while read; do
        [[ -f "$REPLY" ]] && printf "$REPLY\n"
    done < "$hist" > "$temp"

    mv "$temp" "$hist"
}

## Cmd arguments
case "$1" in
    '')
        dir_indicator='[DIR]'
        link_indicator='[LNK]'

        # Pipe file into dmenu with indicator for directories and symbolic links
        filename="$(
            while read; do
                if [[ -d $REPLY ]]; then
                    printf "$dir_indicator $REPLY\n"
                elif [[ -h $REPLY ]]; then
                    printf "$link_indicator $REPLY\n"
                else
                    printf "$REPLY\n"
                fi
            done < "$hist" | "${dmenu_cmd[@]}"
        )"

        [[ -z $filename ]] && err 'Empty selection'

        # Remove indicators
        filename=${filename#@("$dir_indicator "|"$link_indicator ")}

        # If the file doesn't exist clean history and error out
        if ! [[ -e $filename ]]; then
            rm_non_exist
            err "$filename does not exist"
        fi

        entry "$filename"

        "${editor_cmd[@]}" "$filename" ;;

    --open|-o)
        # Absolute path to specified file
        case "$2" in
            '')
                "${editor_cmd[@]}"
                exit ;;
            .)
                filename="$PWD" ;;
            ..)
                cwd="${PWD##*/}"
                filename="${PWD%/$cwd}" ;;
            *)
                filename="$PWD/${2##*/}" ;;
        esac

        entry "$filename"

        "${editor_cmd[@]}" "$filename" ;;

    --purge|-p)
        read -p "Delete $hist? [y/n]: " del
        case "$del" in
            y|Y|yes|Yes|YES) rm -v "$hist" ;;
        esac ;;

    --clean|-c)
        rm_non_exist ;;

    --fill|-f)
        read -p "Replace $hist? [y/n]: " rep
        case "$rep" in
            y|Y|yes|Yes|YES)
                declare -A dirs

                [[ -d $HOME ]] || err 'HOME environment variable not defined'
                
                # dirs[directorypath]=recursionlevel
                dirs["$HOME"]=0
                dirs["$HOME/.local/bin"]=2
                dirs["$HOME/.local/src"]=2
                dirs["$HOME/.config"]=1

                > "$temp"

                append_dir() {
                    # Recursively append files from a directory to temp

                    # Arguments:
                    # $1 = path to a directory
                    # $2 = number of directories to descend (recursive depth)

                    for f in "$1"/*; do
                        if [[ -f $f ]]; then
                            printf '%s\n' "$f"
                        elif [[ -d $f ]]; then
                            printf '%s\n' "$f"
                            [[ $2 -gt 0 ]] && append_dir "$f" $(($2-1))
                        fi
                    done >> "$temp"
                }

                for dir in "${!dirs[@]}"; do
                    append_dir "$dir" "${dirs[$dir]}"

                    # Add to hist if not a subdir already
                    parent="${dir%/*}"
                    sub=0
                    for dir in "${!dirs[@]}"; do
                        [[ $parent == $dir ]] && sub=1
                    done
                    (( sub )) || printf '%s\n' "$dir" >> "$temp"
                done

                mv "$temp" "$hist" ;;
        esac ;;

    --help|-h)
        read  -d '' helptext <<- 'EOF'
			Usage (long options):

			1) Open a new file (or directory) from cmd-line:
			$ dmenu-editor-history --open example.txt
			(intented to be run via a shell alias)

			2) Open a previously opened file from dmenu:
			$ dmenu-editor-history
			(intented to be run via a custom hotkey)

			Clear history:
			$ dmenu-editor-history --purge

			Automatically create a new history:
			$ dmenu-editor-history --fill

			Remove all files from history that does not exist:
			$ dmenu-editor-history --clean
			(this also runs if a non-existent file is selected from dmenu)

			Print out this help text:
			$ dmenu-editor-history --help
		EOF
        printf "$helptext\n" ;;

    *)
        err 'Invalid option(s), see --help for information about usage' ;;
esac
